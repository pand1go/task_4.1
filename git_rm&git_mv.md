### [*>>> к содержанию*](./readme.md)
### [*> следующая страница*](./git_clean.md)
### [*предыдущая страница <*](./git_commit.md)

---

## **Удаление файлов.**

---

#### Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».
#### Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции «Changes not staged for commit» (измененные, но не проиндексированные) вывода команды `git status`:
```
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
```
#### После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.
#### Параметр `-f` применяется для отключения проверки безопасности, с помощью которой Git обеспечивает соответствие файлов в указателе HEAD текущему содержимому раздела проиндексированных файлов и рабочего каталога.
#### Вы также можете удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию `--cached`:
```
$ git rm --cached README
```
#### В команду `git rm` можно передавать файлы, каталоги или шаблоны. Это означает, что вы можете сделать что-то вроде:
```
$ git rm log/\*.log
```
#### Обратите внимание на обратный слеш (`\`) перед `*`. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора. Эта команда удаляет все файлы, имеющие расширение `.log` и находящиеся в каталоге `log/`. Или же вы можете сделать вот так:
```
$ git rm \*~
```
Эта команда удаляет все файлы, имена которых заканчиваются на `~`.
#### **Другие параметры `git rm`:**
```
<file>…
```
#### Указывает файлы, подлежащие удалению. Можно указать один файл, несколько файлов через пробел (`file1 file2 file3`) или шаблон подстановки (`~./directory/*`).​
```
-n
--dry-run
```
#### Параметр `dry run` является защитным механизмом. Он позволяет выполнить пробный запуск команды `git rm` без удаления файлов. В выходных данных отображаются файлы, которые должны были быть удалены.
```
-r
```
#### Параметр `-r` — это сокращение от слова `recursive`. При выполнении команды `git rm` в рекурсивном режиме она удаляет не только каталог назначения, но и все содержимое его вложенных каталогов.
```
 --
```
#### Параметр разделителя позволяет явным образом отличить список имен файлов от аргументов, передаваемых команде `git rm`. Разделитель полезен, когда какие-либо из файлов имеют имена, аналогичные параметрам команды.
```
-q
--quiet
```
#### Параметр `quiet` скрывает вывод команды `git rm`. Как правило, команда выводит по одной строке на каждый удаленный файл.
#### Действие команды `git rm` распространяется только на текущую ветку. Удаление выполняется только в деревьях рабочего каталога и раздела проиндексированных файлов. Удаление файла не сохраняется в истории репозитория до тех пор, пока не создан новый коммит.

---

## **Перемещение файлов. Команда git mv.**

---

#### В отличие от многих других систем контроля версий, Git не отслеживает перемещение файлов явно. Когда вы переименовываете файл в Git, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован.
#### Таким образом, наличие в Git команды `mv` выглядит несколько странным. Если вам хочется переименовать файл в Git, вы можете сделать что-то вроде:
```
$ git mv file_from file_to
```
#### Если вы выполните что-то вроде этого действия и посмотрите на статус, вы увидите, что Git считает, что произошло переименование файла:
```
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
```
#### Однако, это эквивалентно выполнению следующих команд:
```
$ mv README.md README
$ git rm README.md
$ git add README
```
#### Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду `mv`. Единственное отличие состоит лишь в том, что `mv` — одна команда вместо трёх — это функция для удобства. Важнее другое — вы можете использовать любой удобный способ для переименования файла, а затем воспользоваться командами `add`/`rm` перед коммитом.

---

### [*>>> к содержанию*](./readme.md)
### [*> следующая страница*](./git_clean.md)
### [*предыдущая страница <*](./git_commit.md)