### [*>>> к содержанию*](./readme.md)
### [*> следующая страница*](./setting.md)
### [*предыдущая страница <*](./control_versions.md) 

---

# **Краткая история Git**

#### Как и многие великие дела в жизни, Git начался с небольшого творческого разрушения и яростных споров.

#### Ядро Linux — это проект программного обеспечения с открытым исходным кодом довольно большого масштаба. В первые годы обслуживания ядра Linux (1991–2002) изменения в программном обеспечении распространялись в виде исправлений и архивных файлов. В 2002 году проект ядра Linux начал использовать проприетарную DVCS под названием BitKeeper.

#### В 2005 году отношения между сообществом, разработавшим ядро ​​Linux, и коммерческой компанией, разработавшей BitKeeper, разорвались, и статус бесплатного инструмента был отозван. Это побудило сообщество разработчиков Linux (и, в частности, [Линуса Торвальдса][1], создателя [Linux][2] разработать собственный инструмент на основе некоторых уроков, которые они извлекли при использовании BitKeeper. Некоторые из целей новой системы заключались в следующем:
- #### Скорость
- #### Простой дизайн
- #### Мощная поддержка нелинейной разработки (тысячи параллельных веток)
- #### Полностью распределен
- #### Способен эффективно обрабатывать большие проекты, такие как ядро ​​​​Linux (скорость и размер данных)
#### С момента своего рождения в 2005 году Git развивался и совершенствовался, чтобы быть простым в использовании, но при этом сохранить эти первоначальные качества. Он невероятно быстр, очень эффективен при работе с большими проектами и имеет невероятную систему ветвления для нелинейной разработки.

---

# **Что такое Git?**

#### Итак, что такое Git в двух словах? Это важный раздел для усвоения, потому что если вы понимаете, что такое Git и основы его работы, вам, вероятно, будет намного проще эффективно использовать Git. Изучая Git, постарайтесь очистить свой разум от вещей, которые вы, возможно, знаете о других системах контроля версий, таких как [CVS][3], [Subversion][4] или [Perforce][5], — это поможет вам избежать путаницы при использовании инструмента. Несмотря на то, что пользовательский интерфейс Git довольно похож на эти другие системы контроля версий, Git хранит информацию и обрабатывает ее совершенно по-другому, и понимание этих различий поможет вам не запутаться при ее использовании.
#### Основное различие между Git и любой другой системой контроля версий (включая Subversion и ее друзей) заключается в том, как Git думает о своих данных. Концептуально большинство других систем хранят информацию в виде списка изменений в файлах. Эти другие системы (CVS, Subversion, Perforce, [Bazaar][6] и т. д.) рассматривают информацию, которую они хранят, как набор файлов и изменений, вносимых в каждый файл с течением времени (это обычно описывается как *дельта-* контроль версий).

![data storage1](https://git-scm.com/book/en/v2/images/deltas.png)

#### *Рисунок 4. Хранение данных в виде изменений базовой версии каждого файла*

#### Git не думает и не хранит свои данные таким образом. Вместо этого Git думает о своих данных как о серии снимков миниатюрной файловой системы. С Git каждый раз, когда вы фиксируете или сохраняете состояние своего проекта, Git в основном делает снимок того, как все ваши файлы выглядят в данный момент, и сохраняет ссылку на этот снимок. Чтобы быть эффективным, если файлы не изменились, Git не сохраняет файл снова, а только ссылку на предыдущий идентичный файл, который он уже сохранил. Git воспринимает свои данные как **поток снимков**.

![data storage2](https://git-scm.com/book/en/v2/images/snapshots.png)

#### *Рисунок 5. Хранение данных в виде моментальных снимков проекта с течением времени*

#### Это важное различие между Git и почти всеми другими системами контроля версий. Это делает Git больше похожим на мини-файловую систему с несколькими невероятно мощными инструментами, созданными поверх нее, а не просто на систему контроля версий. 
#### Все в Git проверяется контрольной суммой перед сохранением, а затем упоминается по этой контрольной сумме. Это означает, что невозможно изменить содержимое любого файла или каталога без ведома Git. Эта функциональность встроена в Git на самых низких уровнях и является неотъемлемой частью его философии. Вы не можете потерять информацию при передаче или повредить файл, если Git не сможет это обнаружить.

#### Механизм, который Git использует для этой контрольной суммы, называется хэшем SHA-1. Это строка из 40 символов, состоящая из шестнадцатеричных символов (0–9 и a–f) и вычисляемая на основе содержимого файла или структуры каталогов в Git. Хэш SHA-1 выглядит примерно так: 
<pre>
24b9da6552252987aa493b52f8696cd6d3b00373
</pre>
#### Теперь обратите внимание — вот главное, что нужно помнить о Git. У Git есть три основных состояния, в которых могут находиться ваши файлы: *модифицировано*, *поставлено* и *зафиксировано*:
* #### _Измененный означает, что вы изменили файл, но еще не зафиксировали его в своей базе данных._
* #### _Поэтапное означает, что вы пометили измененный файл в его текущей версии, чтобы он попал в ваш следующий моментальный снимок коммита._
* #### _Подтверждение означает, что данные безопасно хранятся в вашей локальной базе данных._
#### Это приводит нас к трем основным разделам проекта Git: рабочему дереву, промежуточной области и каталогу Git.

![working tree](https://git-scm.com/book/en/v2/images/areas.png)

#### *Рисунок 6. Рабочее дерево, промежуточная область и каталог Git*

#### **Рабочее дерево** — это единая проверка одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск для использования или изменения.
#### **Промежуточная область** — это файл, обычно содержащийся в вашем каталоге Git, в котором хранится информация о том, что войдет в ваш следующий коммит. Его техническое название на языке Git — *«индекс»*.

#### **Каталог Git** — это место, где Git хранит метаданные и базу данных объектов для вашего проекта. Это самая важная часть Git, и именно она копируется при клонировании репозитория с другого компьютера.
#### Базовый рабочий процесс Git выглядит примерно так:
1. #### Вы изменяете файлы в своем рабочем дереве.
2. #### Вы выборочно размещаете только те изменения, которые хотите включить в следующую фиксацию, добавляя только эти изменения в область подготовки.
3. #### Вы делаете фиксацию, которая берет файлы в том виде, в котором они находятся в промежуточной области, и постоянно сохраняет этот моментальный снимок в вашем каталоге Git.
#### Если определенная версия файла находится в каталоге Git, она считается *зафиксированной*. Если он был изменен и добавлен в промежуточную область, он является *промежуточным*. И если он был изменен с момента извлечения, но не был подготовлен, он *изменен*.

---

### [*>>> к содержанию*](./readme.md)
### [*> следующая страница*](./setting.md)
### [*предыдущая страница <*](./control_versions.md)

[1]: https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81,_%D0%9B%D0%B8%D0%BD%D1%83%D1%81
[2]: https://ru.wikipedia.org/wiki/Linux
[3]: https://ru.wikipedia.org/wiki/CVS 
[4]: https://ru.wikipedia.org/wiki/Subversion
[5]: https://ru.wikipedia.org/wiki/Perforce
[6]: https://ru.wikipedia.org/wiki/Bazaar