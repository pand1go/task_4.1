<style>
    table {
        border-collapse: collapse;
        border: 2px solid grey;
        }
    th, td {
        text-align: justify;
        padding: 3px;
        border: 1px solid grey;
        }
    body {
        background: rgb(0,33,55);
        color: white;
    }
    h1 {
        color: rgb(201,192,187);  
    }
    h2 {
        color: rgb(201,192,187);
    }
    h4 {
        color: white
    }
</style>

### [*>>> к содержанию*](./readme.md)
### [*> следующая страница*](./git_commit.md)
### [*предыдущая страница <*](./git_diff.md)

---

## **Запись изменений в репозиторий.**

---

#### У вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Вам нужно делать некоторые изменения и фиксировать «снимки» состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.
 #### Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). **Отслеживаемые файлы** — это те файлы, которые были в последнем снимке состояния проекта; они могут быть *неизменёнными*, *изменёнными* или *подготовленными к коммиту*. Если кратко, то **отслеживаемые файлы** — это те файлы, о которых знает Git.
 #### **Неотслеживаемые файлы** — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.
 #### Как только вы отредактируете файлы, Git будет рассматривать их как *изменённые*, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

 ![files state lifecycle](https://git-scm.com/book/en/v2/images/lifecycle.png)

 #### *Рисунок 7. Жизненный цикл состояний файлов*

 ---

 ## **Определение состояния файлов. Команда git status.**

 ---

 #### Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда `git status`. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:
 <pre>
 $ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
</pre>
#### Это означает, что у вас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. Пока что это всегда ветка master, ветка по умолчанию.
#### Предположим, вы добавили в свой проект новый файл, простой файл `README`. Если этого файла раньше не было, и вы выполните `git status`, вы увидите свой неотслеживаемый файл вот так:
<pre>
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add &ltfile>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
</pre>
#### Понять, что новый файл `README` неотслеживаемый можно по тому, что он находится в секции «Untracked files» в выводе команды `status`. Статус `Untracked` означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять.

---

## **Команда git log.**

---

#### Команда `git log` отображает отправленные снимки состояния и позволяет просматривать и фильтровать историю проекта, а также искать в ней конкретные изменения. С помощью `git status` можно просматривать рабочий каталог и раздел проиндексированных файлов, в то время как `git log` показывает только историю коммитов.
![git log](https://wac-cdn.atlassian.com/dam/jcr:52d530ce-7f51-48e3-920b-a18f776048d3/01.svg?cdnVersion=396)

#### *Рисунок 8. Различие команд git status и git log*

#### Существует множество вариантов для настройки выходных данных команды `git log`: от простой фильтрации коммитов до их отображения в пользовательском формате. Ниже показаны наиболее распространенные конфигурации `git log`.
<pre>
git log
</pre>
#### Выводит полную историю коммитов в стандартном формате. Если выходные данные занимают более одного экрана, можно выполнить прокрутку с помощью клавиши 'Пробел' или нажать 'q' для выхода.
<pre>
git log -n &ltlimit>
</pre>
#### Ограничивает число коммитов с помощью параметра. Так, при указании `git log -n 3` отобразится только 3 коммита. 
<pre>
git log --oneline
</pre>
#### Записывает каждый коммит в одну строку. Так можно получить подробный обзор всей истории проекта.
<pre>
git log --stat
</pre>
#### Кроме обычных данных `git log` указывается, какие файлы были изменены, а также относительное число добавленных или удаленных строк в каждом из них.
<pre>
git log -p
</pre>
#### Выводит патчи, соответствующие определенным коммитам. Это самое подробное представление истории проекта, поскольку так можно просмотреть полный список изменений каждого коммита.
<pre>
git log --author="&ltpattern>"
</pre>
#### Выполняет поиск коммитов конкретного автора. Аргумент  может быть обычной строкой или регулярным выражением.
<pre>
git log --grep="&ltpattern>"
</pre>
#### Выполняет поиск коммитов с сообщениями, соответствующими аргументу. Этот аргумент может быть обычной строкой или регулярным выражением.
<pre>
git log &ltsince>..&ltuntil>
</pre>
#### Отображает только коммиты в диапазоне значений `<since>` и `<until>`. Эти аргументы могут быть идентификаторами коммитов, именами веток, указателями `HEAD` или другими ссылками на версии.
<pre>
git log &ltfile>
</pre>
#### Выводит только коммиты, содержащие указанный файл. Так можно удобно просмотреть историю конкретного файла.
<pre>
git log --graph --decorate --oneline
</pre>
#### Здесь содержится несколько полезных параметров: флаг `--graph` создает основанную на тексте диаграмму коммитов в левой части области сообщений коммитов; флаг `--decorate` добавляет отображаемые имена веток или теги коммитов; флаг `--oneline` записывает информацию о коммите в одну строку, что позволяет без труда просматривать множество коммитов сразу.
#### Следующей действительно полезной опцией является `--pretty`. Эта опция меняет формат вывода. Существует несколько встроенных вариантов отображения. Опция `oneline` выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов. К тому же, опции `short`, `full` и `fuller` делают вывод приблизительно в том же формате, но с меньшим или большим количеством информации соответственно:
<pre>
$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 Change version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Remove unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 Initial commit
</pre>
#### Наиболее интересной опцией является `format`, которая позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git:
<pre>
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : Change version number
085bb3b - Scott Chacon, 6 years ago : Remove unnecessary test
a11bef0 - Scott Chacon, 6 years ago : Initial commit
</pre>
#### Полезные опции для `git log --pretty=format`:

<table>
    <tr>
        <th> <h4> <strong> Опция </strong> </h4> </th>
        <th> <h4> <strong> Описания вывода </strong> </h4> </th>
    </tr>
    <tr>
        <td> <h4> <code>%H</code> </h4> </td>
        <td> <h4> Хеш коммита </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%h</code> </h4> </td>
        <td> <h4> Сокращенный хеш коммита </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%T</code> </h4> </td>
        <td> <h4> Хеш дерева </td>
    </tr>
    <tr>
        <td> <h4> <code>%t</code> </h4> </td>
        <td> <h4> Сокращенный хеш дерева </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%P</code> </td>
        <td> <h4> Хеш родителей </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%p</code> </h4> </td>
        <td> <h4> Сокращенный хеш родителей </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%an</code> </h4> </td>
        <td> <h4> Имя автора </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%ae</code> </h4> </td>
        <td> <h4> Электронная почта автора </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%ad</code> </h4> </td>
        <td> <h4> Дата автора (формат даты можно задать опцией --date=option) </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%ar</code> </h4> </td>
        <td> <h4> Относительная дата автора </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%cn</code> </h4> </td>
        <td> <h4> Имя коммитера </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%ce</code> </h4> </td>
        <td> <h4> Электронная почта коммитера </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%cd</code> </h4> </td>
        <td> <h4> Дата коммитера </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%cr</code> </h4> </td>
        <td> <h4> Относительная дата коммитера </h4> </td>
    </tr>
    <tr>
        <td> <h4> <code>%s</code> </h4> </td>
        <td> <h4> Содержание </h4> </td>
    </tr>
</table>

#### Разница между автором и коммитером. *Автор* — это человек, изначально сделавший работу, а *коммитер* — это человек, который последним применил эту работу. Другими словами, если вы создадите патч для какого-то проекта, а один из основных членов команды этого проекта применит этот патч, вы оба получите статус участника — вы как автор и основной член команды как коммитер.
---

## **Сокращенный вывод статуса**

---

#### Вывод команды `git status` довольно всеобъемлющий и многословный. Git также имеет флаг вывода сокращенного статуса, так что вы можете увидеть изменения в более компактном виде. Если вы выполните `git status -s` или `git status --short` вы получите гораздо более упрощенный вывод:
<pre>
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</pre>
#### Новые неотслеживаемые файлы помечены `??` слева от них, файлы добавленные в отслеживаемые помечены `A`, отредактированные файлы помечены `M` и так далее. В выводе содержится два столбца — в левом указывается статус файла, а в правом модифицирован ли он после этого. К примеру в нашем выводе, файл `README` модифицирован в рабочем каталоге, но не проиндексирован, а файл `lib/simplegit.rb` модифицирован и проиндексирован. Файл `Rakefile` модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть те изменения, которые попадут в коммит, и те, которые не попадут.

---

### [*>>> к содержанию*](./readme.md)
### [*> следующая страница*](./git_commit.md)
### [*предыдущая страница <*](./git_diff.md)